local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local player = game.Players.LocalPlayer
local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
player.CharacterAdded:Connect(function(char)
	character = char
end)

local name = string.format("%sBoat", player.Name)

local defaultWalkSpeed 

local runService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Window = Library:CreateWindow({
	Title = "Kintama Hack",
	Center = false,
	AutoShow = true,
	TabPadding = 8,
	MenuFadeTime = 0.2
})

local Tabs = {
	Main = Window:AddTab('Main'),
	Op = Window:AddTab('Op'),
	['UI Settings'] = Window:AddTab('UI Settings'),
}


-- TABLES
local chestEsps = {}
local DarkSeaEsps = {}
local espParts = Instance.new("Folder", workspace)
local enemies = {}
local enemyConns = {}


-- HELPER STUFF

function createText(text, color, object, distance)
	local billboard = Instance.new("BillboardGui")
	billboard.Size = UDim2.new(0, 70, 0, 30)
	billboard.AlwaysOnTop = true
	billboard.StudsOffset = Vector3.new(0, 2, 0) 
	billboard.MaxDistance = distance or math.huge 
	billboard.LightInfluence = 0 
	billboard.Parent = espParts
	billboard.Adornee = object
	billboard.Name = "EspBillboard"

	local label = Instance.new("TextLabel")
	label.Parent = billboard
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = text
	label.TextColor3 = color or Color3.new(1, 1, 1)
	label.TextStrokeTransparency = 0.5
	label.Font = Enum.Font.GothamBold
	label.TextScaled = true
	label.TextYAlignment = Enum.TextYAlignment.Center
	label.TextXAlignment = Enum.TextXAlignment.Center
	label.Name = "EspText"

	return billboard
end

for _, enemy in ipairs(workspace.Enemies:GetChildren()) do
	if enemy:IsA("Model") then
		enemies[enemy] = true
	end
end

for _, enemy in ipairs(game.Players:GetPlayers()) do
	if enemy == player then continue end
	if enemy.Character then
		enemies[enemy.Character] = enemy.Character
	end
end

enemyConns[1] = workspace.Enemies.ChildAdded:Connect(function(enemy)
	if enemy:IsA("Model") then
		enemies[enemy] = enemy
	end
end)

enemyConns[2] = workspace.Enemies.ChildRemoved:Connect(function(enemy)
	enemies[enemy] = nil
end)

enemyConns[3] = workspace.ChildAdded:Connect(function(enemy)
	if enemy:FindFirstChild("Humanoid") then
		enemies[enemy] = enemy
	end
end) 

enemyConns[4] = workspace.ChildRemoved:Connect(function(enemy)
	if enemy:FindFirstChild("Humanoid") then
		enemies[enemy] = nil
	end
end)

-- CONNECTIONS

local AttackToggleConn
local CannonToggleConn
local DarkSeaConns = {}
local ChestAddConns = {}
local ChestRemoveConns = {}
local godModeTask
local autoFishConn
local ESPConnection
local ESP_OBJECTS = {}

local disableFunctions = {
	AttackToggle = function()
		if AttackToggleConn  then
			AttackToggleConn:Disconnect()
			AttackToggleConn = nil
		end
	end,
	CannonToggle = function()
		if CannonToggleConn  then
			CannonToggleConn:Disconnect()
			CannonToggleConn = nil
		end
	end,
	SpeedToggle = function()
		runService:UnbindFromRenderStep("walkspeedToggle")
		local humanoid = character and character:FindFirstChild("Humanoid")
		if humanoid and defaultWalkSpeed then
			humanoid.WalkSpeed = defaultWalkSpeed
		end
	end,
	FlyToggle = function()
		runService:UnbindFromRenderStep("HackFly")
		local humanoid = character and character:FindFirstChild("Humanoid")
		local rootPart = character and character:FindFirstChild("HumanoidRootPart")

		if humanoid then
			humanoid.PlatformStand = false
		end
	end,
	NoClipToggle = function()
		runService:UnbindFromRenderStep("NoClipHack")
		if character then
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = true
				end
			end
		end
	end,
	RotationToggle = function()
		runService:UnbindFromRenderStep("RotationHack")
		local boat = workspace.Boats:FindFirstChild(name)
		local center = boat and boat:FindFirstChild("Center")

		if boat and center then
			center.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
		end
	end,
	BoatSpeedToggle = function()
		runService:UnbindFromRenderStep("BoatSpeedHack")
		local boat = workspace.Boats:FindFirstChild(name)
		local center = boat and boat:FindFirstChild("Center")

		if boat and center then
			center.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
		end
	end,
	CtrlClickToggle = function()
		runService:UnbindFromRenderStep("CtrlClickToggle")
	end,
	ChestEspToggle = function()
		for chest, esp in pairs(chestEsps) do
			esp:Destroy()
			chestEsps[chest] = nil
		end
		if ChestAddConns then
			for i, conn in pairs(ChestAddConns) do
				conn:Disconnect()
				ChestAddConns[i] = nil
			end
		end
		if ChestRemoveConns then
			for i, conn in pairs(ChestRemoveConns) do
				conn:Disconnect()
				ChestRemoveConns[i] = nil
			end
		end
	end,
	InfJumpToggle = function()
		runService:UnbindFromRenderStep("InfJumpToggle")
	end,
	DarkSeaEsp = function()
		for i, conn in ipairs(DarkSeaConns) do
			conn:Disconnect()
			DarkSeaConns[i] = nil
		end

		for i, esp in DarkSeaEsps do
			esp:Destroy()
			DarkSeaEsps[i] = nil
		end
	end,
	EnemyConnsClear = function()
		for i, conn in ipairs(enemyConns) do
			conn:Disconnect()
			enemyConns[i] = nil
		end
		enemies = nil
	end,
	GodModeToggle = function()
		if godModeTask and hookmetamethod then
			hookmetamethod(game, "__namecall", godModeTask)
		end
	end,
	AutoFishToggle = function()
		if autoFishConn then
			autoFishConn:Disconnect()
			autoFishConn = nil
		end
	end,
	PlayerEspToggle	= function()
			for _, PlayerData in pairs(ESP_OBJECTS) do
				for _, Drawing in pairs(PlayerData.drawings) do
					Drawing.Visible = false
					Drawing:Remove()
				end
			end
			ESP_OBJECTS = {}

			if ESPConnection then
				ESPConnection:Disconnect()
				ESPConnection = nil
			end
		end

}
-----

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Attack Teleports')
local MovementBox = Tabs.Main:AddRightGroupbox("Movement")
local OtherBox = Tabs.Main:AddLeftGroupbox("Other")
local LeftOpBox = Tabs.Op:AddLeftGroupbox('Op')
local RightOpBox = Tabs.Op:AddRightGroupbox('Item Stats')

LeftGroupBox:AddInput("TeleportName",
	{
		Default = "",
		Finished = true,
		Text = "Target by enemey name",
		Tooltip = "Makes your blasts teleport to target. Write player username if target player. Write nothing if disable"
	}
)

LeftGroupBox:AddToggle('PvpToggle', {
	Text = 'Toggle tp attack to player',
	Default = false,
	Tooltip = 'If enabled then attacks will also tp to players (not you)'
})

LeftGroupBox:AddToggle("PveToggle",{
	Text = 'Toggle tp attack to npc',
	Default = true,
	Tooltip = 'If enabled then attacks will tp to npcs'
})
LeftGroupBox:AddToggle("AttackToggle", {
	Text = "Tp attacks closest enemy",
	Default = false,
	Tooltip = "Tp attacks to closest enemy currently only works with magic blasts \n (magic m1 and the first magic move)",
	Callback = function(Value)
		local function getClosestEnemy()
			if not character then return nil end

			local hrp = character:FindFirstChild("HumanoidRootPart")
			if not hrp then return nil end
			local pve = Toggles.PveToggle.Value
			local pvp = Toggles.PvpToggle.Value

			local closestEnemy
			if #Options.TeleportName.Value > 0 then
				local name = Options.TeleportName.Value
				if pvp then
					if game.Players:FindFirstChild(name) then
						closestEnemy = game.Players[name].Character
					end
				end
				if not closestEnemy and pve then
					if workspace.Enemies:FindFirstChild(name) then
						closestEnemy = workspace.Enemies[name]
					end
				end
			else
				local mobDist = math.huge
				for enemy in pairs(enemies) do
					if not pvp and enemy.Parent == workspace then
						continue
					end
					if not pve and enemy.Parent == workspace.Enemies then
						continue
					end

					local enemyHRP = enemy:FindFirstChild("HumanoidRootPart")
					local hum = enemy:FindFirstChildOfClass("Humanoid")
					if hum then
						if hum.Health <= 0 then
							continue
						end
					else
						local atts = enemy:FindFirstChild("Attributes")
						if atts then
							local Health = atts:FindFirstChild("Health")
							if not Health or Health.Value <= 0 then
								continue
							end
						end
					end
					if enemyHRP then
						local distance = (enemyHRP.Position - hrp.Position).Magnitude
						if distance < mobDist then
							mobDist = distance
							closestEnemy = enemy
						end
					end
				end
			end
			return closestEnemy
		end
		local function tpToTarget(effect)
			if effect.Name == "Blast" then

				local target = getClosestEnemy()
				if not target then return end

				local targetHRP = target:FindFirstChild("HumanoidRootPart")
				if not targetHRP then return end

				if effect:IsA("BasePart") then
					task.spawn(function()
						while effect.Parent == workspace.Effects do
							if target and targetHRP then
								effect.CFrame = targetHRP.CFrame
								task.wait()
							else break
							end
						end
					end)
				end					
			end
		end

		if Value then
			AttackToggleConn = workspace.Effects.ChildAdded:Connect(function(child)
				if child:IsA("BasePart") then
					tpToTarget(child)
				end
			end)
		else
			disableFunctions["AttackToggle"]()
		end
	end
}):AddKeyPicker("AttackToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "Blast teleport toggle"
})

LeftGroupBox:AddDivider()

LeftGroupBox:AddToggle('CannonPvpToggle', {
	Text = 'Tps player ship',
	Default = false,
	Tooltip = 'If enabled then cannonballs will also tp to nearest plr ship'
})

LeftGroupBox:AddToggle("CannonPveToggle",{
	Text = 'Tps bot ship',
	Default = true,
	Tooltip = 'If enabled then cannonballs will tp to nearest bot ship'
})

LeftGroupBox:AddToggle("CannonFortToggle",{
	Text = 'Tps fort (overrides others)',
	Default = false,
	Tooltip = 'Tps cannonballs to either fort castrum or fort montu (will auto select)'
})

LeftGroupBox:AddToggle("CannonToggle",{
	Text = 'Tps cannonballs to ship',
	Default = false,
	Tooltip = 'If enabled then cannonballs will tp to nearest ship',
	Callback = function(Value)
		local function getClosestBoat()

			local hrp = character and character:FindFirstChild("HumanoidRootPart")
			if not hrp then return nil end

			local closestBoat = nil
			local closestDistance = math.huge
			local pvp = Toggles.CannonPvpToggle.Value
			local pve = Toggles.CannonPveToggle.Value
			for _, boat in ipairs(workspace.Boats:GetChildren()) do
				if boat:IsA("Model") and boat.PrimaryPart then
					local owner = boat:FindFirstChild("Owner")
					local dura = boat:FindFirstChild("Dura") 
					if not dura or dura.Value <= 0 then
						continue
					end
					if owner and owner.Value then
						if not pvp then continue end
						if owner.Value == player then continue end
					else
						if not pve then continue end
					end

					local distance = (boat.PrimaryPart.Position - hrp.Position).Magnitude
					if distance < closestDistance then
						closestDistance = distance
						closestBoat = boat
					end
				end
			end

			return closestBoat
		end

		local function tpToTarget(effect)
			if effect.Name ~= "Cannonball" then
				return
			end

			if not effect:IsA("BasePart") then
				return
			end
			if Toggles.CannonFortToggle.Value then
				task.spawn(function()
					local placeId = game.PlaceId
					local tCF = CFrame.new(0,0,0)
					if placeId == 12604352060 then
						tCF = CFrame.new(18924.5762, 460.34613, 12807.1475)
					elseif placeId == 15449776494 then
						tCF = CFrame.new(3044.59399, 515.677246, -8690.51758)
					end
					while effect.Parent == workspace.Effects do
						effect.CFrame = tCF
						task.wait()						
					end
				end)
			else
				local targetBoat = getClosestBoat()
				if not targetBoat then return end

				local targetPart = targetBoat.PrimaryPart
				if not targetPart then return end

				task.spawn(function()
					while effect.Parent == workspace.Effects do
						if targetBoat and targetPart then
							effect.CFrame = targetPart.CFrame
							task.wait()
						else break
						end
					end
				end)
			end
		end

		if Value then
			CannonToggleConn = workspace.Effects.ChildAdded:Connect(function(child)

				tpToTarget(child)
			end)
		else
			disableFunctions["CannonToggle"]()
		end
	end
}):AddKeyPicker("CannonToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "Cannon Tp Toggle"
})

MovementBox:AddInput("SpeedBox",
	{
		Default = "100",
		Numeric = true,
		Finished = true,
		Text = "Insert movement speed",
		Tooltip = ""
	}
)

MovementBox:AddToggle("SpeedToggle",{
	Text = 'Activate speed hack',
	Default = false,
	Tooltip = 'Go fast',
	Callback = function(Value)
		if Value then
			local humanoid = character and character:FindFirstChild("Humanoid")
			if not humanoid then
				Toggles.SpeedToggle:SetValue(false)
				return
			end
			defaultWalkSpeed = humanoid.WalkSpeed

			runService:BindToRenderStep("walkspeedToggle", 0, function()
				local char = character
				local humanoid = char:FindFirstChild("Humanoid")
				if char and humanoid then
					humanoid.WalkSpeed = Options.SpeedBox.Value
				end
			end)
		else
			disableFunctions["SpeedToggle"]()
		end

	end}):AddKeyPicker("SpeedToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "Speed hack toggle"
})

MovementBox:AddInput("FlyBox",
	{
		Default = "100",
		Numeric = true,
		Finished = true,
		Text = "Insert fly speed",
		Tooltip = ""
	}
)
MovementBox:AddToggle("FlyToggle",{
	Text = 'Activate fly hack',
	Default = false,
	Tooltip = 'Go fly',
	Callback = function(Value)

		local function enableFly()

			local humanoid = character and character:FindFirstChild("Humanoid")
			local rootPart = character and character:FindFirstChild("HumanoidRootPart")

			runService:BindToRenderStep("HackFly", 0, function()
				local humanoid = character and character:FindFirstChild("Humanoid")
				local rootPart = character and character:FindFirstChild("HumanoidRootPart")
				if not rootPart then return end

				humanoid.PlatformStand = true
				rootPart.Anchored = false

				local flySpeed = Options.FlyBox.Value
				local camera = workspace.CurrentCamera
				local direction = Vector3.new(0, 0, 0)

				if UserInputService:IsKeyDown(Enum.KeyCode.W) then
					direction = direction + camera.CFrame.LookVector
				end
				if UserInputService:IsKeyDown(Enum.KeyCode.S) then
					direction = direction - camera.CFrame.LookVector
				end
				if UserInputService:IsKeyDown(Enum.KeyCode.A) then
					direction = direction - camera.CFrame.RightVector
				end
				if UserInputService:IsKeyDown(Enum.KeyCode.D) then
					direction = direction + camera.CFrame.RightVector
				end
				if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
					direction = direction + Vector3.new(0, 1, 0)
				end
				if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
					direction = direction + Vector3.new(0, -1, 0)
				end

				if direction.Magnitude > 0 then
					direction = direction.Unit * flySpeed
					rootPart.AssemblyLinearVelocity = direction

				else
					rootPart.AssemblyLinearVelocity = Vector3.new(0,3.5,0)

				end
				rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + camera.CFrame.LookVector)
			end)
		end



		if Value then enableFly() else disableFunctions["FlyToggle"]() end
	end}):AddKeyPicker("FlyToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "Toggle fly hack"
})


Library:SetWatermarkVisibility(false)

Library.KeybindFrame.Visible = true; 

MovementBox:AddToggle("NoClipToggle",{
	Text = 'Activate no clip hack',
	Default = false,
	Tooltip = 'Go through walls',
	Callback = function(Value)
		local function enableNoClip()
			runService:BindToRenderStep("NoClipHack", 0, function()

				if character then
					for _, part in pairs(character:GetDescendants()) do
						if part:IsA("BasePart") then
							part.CanCollide = false
						end
					end
				end
			end)
		end

		if Value then enableNoClip() else disableFunctions["NoClipToggle"]() end

	end}):AddKeyPicker("NoClipToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "NoClip"
})

MovementBox:AddToggle("InfJumpToggle",{
	Text = 'Activate infinite jump hack',
	Default = false,
	Tooltip = 'Go high up',
	Callback = function(Value)

		if Value then 
			runService:BindToRenderStep("InfJumpToggle", 1, function()
				local root = character and character:FindFirstChild("HumanoidRootPart")
				if root and UserInputService:IsKeyDown(Enum.KeyCode.Space) then
					root.Velocity = Vector3.new(root.Velocity.X, 45, root.Velocity.Z)
				end
			end)
		else disableFunctions["InfJumpToggle"]() end

	end}):AddKeyPicker("InfJumpkey", {
	Default = "",
	SyncToggleState = true,
	Text = "Infinite Jump"
})
MovementBox:AddDivider()

MovementBox:AddInput("RotationBox",
	{
		Default = "50",	
		Numeric = true,
		Finished = true,
		Text = "Insert boat rotation speed",
		Tooltip = ""
	}
)
MovementBox:AddToggle("RotationToggle",{
	Text = 'Fast ship rotation (buggy)',
	Default = false,
	Tooltip = 'makes some ships rotate faster. Wont enable if no boat',
	Callback = function(Value)
		local rotationSpeed = Options.RotationBox.Value
		local name = string.format("%sBoat", player.Name)


		if Value then runService:BindToRenderStep("RotationHack", 0, function()
				local boat = workspace.Boats:FindFirstChild(name)

				local center = boat and boat:FindFirstChild("Center")
				if center then
					local steer = 0
					if UserInputService:IsKeyDown(Enum.KeyCode.A) then
						steer = rotationSpeed
					elseif UserInputService:IsKeyDown(Enum.KeyCode.D) then
						steer = -rotationSpeed
					end
					if boat and center then
						center.AssemblyAngularVelocity = Vector3.new(0, steer, 0)
					else
						runService:UnbindFromRenderStep("RotationHack")
						Toggles.RotationToggle:SetValue(false)
					end
				end
			end)


		else 
			disableFunctions["RotationToggle"]()
		end
	end,
})
MovementBox:AddInput("BoatSpeedbox",
	{
		Default = "10000",
		Numeric = true,
		Finished = true,
		Text = "Insert boat speed",
		Tooltip = ""
	}
)
MovementBox:AddToggle("BoatSpeedToggle",{
	Text = 'Toggle to increase boat speed',
	Default = false,
	Tooltip = 'If enabled then boat will be a lot faster. W/S backwards/forwards. It will be remote controlled also. WOnt enable if no boat',
	Callback = function(Value)
		if Value then runService:BindToRenderStep("BoatSpeedHack", 0, function()
				local boat = workspace.Boats:FindFirstChild(name)

				local center = boat and boat:FindFirstChild("Center")
				if center then
					local throttle = 0
					if UserInputService:IsKeyDown(Enum.KeyCode.W) then
						throttle = 1
					elseif UserInputService:IsKeyDown(Enum.KeyCode.S) then
						throttle = -1
					end
					local cf = center.CFrame
					center.Anchored = false

					local desiredLinearVel = cf.LookVector * throttle * Options.BoatSpeedbox.Value
					center.AssemblyLinearVelocity = center.AssemblyLinearVelocity:Lerp(desiredLinearVel, 0.13)
				end

			end)

		else 
			disableFunctions["BoatSpeedToggle"]()
		end
	end,
})

MovementBox:AddDivider()

MovementBox:AddButton({
	Text = "Teleport current story quest",
	Func = function()
		if workspace.Camera:FindFirstChild("StoryMarker1") then
			if character and character.HumanoidRootPart then
				character.HumanoidRootPart.CFrame = workspace.Camera.StoryMarker1.CFrame
			end
		end
	end,
	Tooltip = "Teleports to current story quest if marker exists"
})

MovementBox:AddButton({
	Text = "Other story quest marker tp",
	Func = function()
		if character and character.HumanoidRootPart then
			for _, child in ipairs(workspace.NPCs:GetDescendants()) do
				if child:IsA("BillboardGui") then
					if child.Name == "Story" then
						character.HumanoidRootPart.CFrame = child.Parent.CFrame
					end
				end
			end
		end
	end,
	Tooltip = "Teleports to current story quest if marker exists. \n It will tp to the question mark symbol instead. Laggier. "
})

MovementBox:AddButton({
	Text = "Tp current quest",
	Func = function()
		if workspace.Camera:FindFirstChild("QuestMarker1") then
			if character and character.HumanoidRootPart then
				character.HumanoidRootPart.CFrame = workspace.Camera.QuestMarker1.CFrame
			end
		end
	end,
	Tooltip = "Teleports to current quest if marker exists."
})

MovementBox:AddButton({
	Text = "Tp to ship",
	Func = function()
		local ship= workspace.Boats:FindFirstChild(name)
		if ship then
			if ship:FindFirstChild("Grate") then
				if character and character.HumanoidRootPart then
					character.HumanoidRootPart.CFrame = ship.Grate.CFrame
				end
			else
				character.HumanoidRootPart.CFrame = ship.WorldPivot
			end
		end
	end,
	Tooltip = "Teleports to your ship if it exists."
})

local dropDownIsland = {}
if workspace:FindFirstChild("Map") then
	for _, folder in ipairs(workspace.Map:GetChildren()) do
		if folder:FindFirstChild("Center") then
			table.insert(dropDownIsland, folder.Name)
		end
	end
end

MovementBox:AddDropdown('IslandTp', {
	Values = dropDownIsland,
	Default = 0, 
	Multi = false, 

	Text = 'Tp to island',
	Tooltip = 'Tps you to selected island', 

	Callback = function(Value)
		if character and character.HumanoidRootPart then
			character.HumanoidRootPart.CFrame = workspace.Map[Value]["Center"].CFrame
		end
	end
})

MovementBox:AddToggle("CtrlClickToggle",{
	Text = 'Ctrl click tp to cursor',
	Default = false,
	Tooltip = 'If you hold down control and click/hold m1 then you tp to cursor position',
	Callback = function(Value)
		if Value then
			local canTp = true
			runService:BindToRenderStep("CtrlClickToggle", Enum.RenderPriority.Input.Value, function()
				local hrp = character and character:FindFirstChild("HumanoidRootPart") 
				if not character:FindFirstChild("HumanoidRootPart") then return end
				if canTp then
					local mouse = player:GetMouse()
					if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl) then
						if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
							local targetPos = mouse.Hit and mouse.Hit.Position
							if targetPos then
								canTp = false
								character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
								task.delay(0.15, function()
									canTp =true
								end)
							end
						end
					end
				end
			end)
		else
			disableFunctions["CtrlClickToggle"]()
		end
	end,
})

OtherBox:AddLabel('Chest Esp Color'):AddColorPicker('ChestEspColor', {
	Default = Color3.new(1, 1, 1), 
	Title = 'CHEST ESP COLOR', 
})

OtherBox:AddToggle("TreasureChestToggle",{
	Text = 'Toggle "treasure chest" esp',
	Default = false,
	Tooltip = 'Will make chest esp show/hide chests with name "Treasure Chest" \n You have to re enable chest esp to update',

})


local function trackChest(chest)
	local obj =  chest:FindFirstChild("ChestObj") 
	if obj and chest.Name ~= "Private Storage" and (chest.Name ~= "Treasure Chest" or Toggles.TreasureChestToggle.Value)  and not chest:FindFirstChild("Open") then
		if chest:IsA("Model") then
			local part = chest.PrimaryPart or chest:FindFirstChildWhichIsA("BasePart")
			if part then
				local color = Options.ChestEspColor.Value
				if chest.Name ~= "Treasure Chest" and chest.Name ~= "Uncommon Chest" and chest.Name ~= "Rare Chest" then
					local h, s, v = color:ToHSV()
					color = Color3.fromHSV((h + 0.5) % 1, math.clamp(s + 0.4, 0.7, 1), math.clamp(v + 0.2, 0.7, 1))
				end
				local esp = createText(chest.Name, color, part)
				chestEsps[chest] = esp
				ChestRemoveConns[chest] = chest.ChildAdded:Connect(function(child)
					if child.Name == "Open" then
						esp:Destroy()
						chestEsps[chest] = nil
						ChestRemoveConns[chest]:Disconnect()
						ChestRemoveConns[chest] = nil
					end
				end)
			end
		end
	end
end

OtherBox:AddToggle("ChestEspToggle", {
	Text = 'Chest esp (dont spam pick chests)',
	Default = false,
	Tooltip = 'Allows you to see all the chests on the map. (use responsibly) \n might kick you if you lag too much',
	Callback = function(Value)
		if Value then
			local iterate = {
				workspace.Map,
				game.ReplicatedStorage.RS.UnloadIslands
			}
			for _, parent in ipairs(iterate) do
				for _, island in ipairs(parent:GetChildren()) do
					for _, v in ipairs(island:GetChildren()) do
						if typeof(v) == "Instance" and v.Name == "Chests" then
							for _, chest in v:GetChildren() do
								trackChest(chest)
							end
							ChestAddConns[v] = v.ChildAdded:Connect(function(chest)
								trackChest(chest)
							end)
						end
					end
				end
			end
		else
			disableFunctions["ChestEspToggle"]()
		end
	end,
}):AddKeyPicker("ChestEspToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "Chest esp"
})

local Camera = workspace.CurrentCamera

local LocalPlayer = player
local ESPConnection

local function WorldToScreen(Position)
	local ScreenPoint, OnScreen = Camera:WorldToViewportPoint(Position)
	return Vector2.new(ScreenPoint.X, ScreenPoint.Y), OnScreen, ScreenPoint.Z > 0
end

local function CreateDrawings()
	local Drawings = {}
	Drawings.Box = Drawing.new("Square")
	Drawings.Box.Color = Color3.fromRGB(255, 255, 255)
	Drawings.Box.Thickness = 2
	Drawings.Box.Filled = false
	Drawings.Box.Transparency = 1
	Drawings.Box.Visible = false
	Drawings.HealthBg = Drawing.new("Square")
	Drawings.HealthBg.Color = Color3.fromRGB(0, 0, 0)
	Drawings.HealthBg.Thickness = 1
	Drawings.HealthBg.Filled = true
	Drawings.HealthBg.Transparency = 0.7
	Drawings.HealthBg.Visible = false
	Drawings.HealthFill = Drawing.new("Square")
	Drawings.HealthFill.Color = Color3.fromRGB(0, 255, 0)
	Drawings.HealthFill.Thickness = 1
	Drawings.HealthFill.Filled = true
	Drawings.HealthFill.Transparency = 1
	Drawings.HealthFill.Visible = false
	Drawings.DistanceText = Drawing.new("Text")
	Drawings.DistanceText.Color = Color3.fromRGB(255, 255, 255)
	Drawings.DistanceText.Size = 14
	Drawings.DistanceText.Font = 2
	Drawings.DistanceText.Outline = true
	Drawings.DistanceText.OutlineColor = Color3.fromRGB(0, 0, 0)
	Drawings.DistanceText.Center = true
	Drawings.DistanceText.Visible = false
	Drawings.NameText = Drawing.new("Text")
	Drawings.NameText.Color = Color3.fromRGB(255, 255, 255)
	Drawings.NameText.Size = 14
	Drawings.NameText.Font = 2
	Drawings.NameText.Outline = true
	Drawings.NameText.OutlineColor = Color3.fromRGB(0, 0, 0)
	Drawings.NameText.Center = true
	Drawings.NameText.Visible = false
	return Drawings
end

local function UpdateESP(PlayerData, LocalRoot)
	local Character = PlayerData.player.Character
	local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
	local Head = Character and Character:FindFirstChild("Head")
	local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
	if not (Character and Humanoid and Head and RootPart and LocalRoot) then
		return false
	end
	local HealthPercent = math.clamp(Humanoid.Health / Humanoid.MaxHealth, 0, 1)
	local TopPoint, TopOnScreen, TopInFront = WorldToScreen(Head.Position + Vector3.new(0, 1, 0))
	local BottomPoint, BottomOnScreen, BottomInFront = WorldToScreen(RootPart.Position - Vector3.new(0, 3, 0))
	local Drawings = PlayerData.drawings
	if not (TopOnScreen and BottomOnScreen and TopInFront and BottomInFront) then
		Drawings.Box.Visible = false
		Drawings.HealthBg.Visible = false
		Drawings.HealthFill.Visible = false
		Drawings.DistanceText.Visible = false
		Drawings.NameText.Visible = false
		return true
	end
	local BoxHeight = math.abs(BottomPoint.Y - TopPoint.Y)
	local BoxWidth = BoxHeight / 2
	local BoxX = TopPoint.X - BoxWidth / 2
	local BoxY = TopPoint.Y
	Drawings.Box.Position = Vector2.new(BoxX, BoxY)
	Drawings.Box.Size = Vector2.new(BoxWidth, BoxHeight)
	Drawings.Box.Visible = true
	local BarX = BoxX - 8
	local BarWidth = 4
	local BarHeight = BoxHeight
	Drawings.HealthBg.Position = Vector2.new(BarX, BoxY)
	Drawings.HealthBg.Size = Vector2.new(BarWidth, BarHeight)
	Drawings.HealthBg.Visible = true
	local FillHeight = BarHeight * HealthPercent
	local FillY = BoxY + BarHeight - FillHeight
	Drawings.HealthFill.Position = Vector2.new(BarX + 1, FillY)
	Drawings.HealthFill.Size = Vector2.new(BarWidth - 2, FillHeight)
	Drawings.HealthFill.Visible = true
	local Distance = (RootPart.Position - LocalRoot.Position).Magnitude
	Drawings.DistanceText.Text = tostring(math.floor(Distance)) .. " studs"
	Drawings.DistanceText.Position = Vector2.new(TopPoint.X, BoxY - 18)
	Drawings.DistanceText.Visible = true
	Drawings.NameText.Text = PlayerData.player.Name
	Drawings.NameText.Position = Vector2.new(TopPoint.X, BoxY - 36)
	Drawings.NameText.Visible = true
	return true
end

local function ESPLoop()
	local LocalCharacter = LocalPlayer.Character
	local LocalRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
	if not LocalRootPart then
		return
	end

	for Player, PlayerData in pairs(ESP_OBJECTS) do
		if not Players:FindFirstChild(Player.Name) then
			for _, Drawing in pairs(PlayerData.drawings) do
				Drawing:Remove()
			end
			ESP_OBJECTS[Player] = nil
		else
			local ShouldKeep = UpdateESP(PlayerData, LocalRootPart)
			if not ShouldKeep then
				for _, Drawing in pairs(PlayerData.drawings) do
					Drawing:Remove()
				end
				ESP_OBJECTS[Player] = nil
			end
		end
	end

	for _, Player in ipairs(Players:GetPlayers()) do
		if Player ~= LocalPlayer and Player.Character and not ESP_OBJECTS[Player] then
			local Drawings = CreateDrawings()
			ESP_OBJECTS[Player] = {
				player = Player,
				drawings = Drawings
			}
		end
	end
end



OtherBox:AddToggle("PlayerEspToggle", {
	Text = 'Player ESP',
	Default = false,
	Tooltip = 'Shows all player locations',
	Callback = function(Value)
		if Value then
			if not ESPConnection then
				ESPConnection = runService.RenderStepped:Connect(ESPLoop)
			end
			local LocalCharacter = LocalPlayer.Character
			local LocalRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
			if LocalRootPart then
				for _, Player in ipairs(Players:GetPlayers()) do
					if Player ~= LocalPlayer and Player.Character and not ESP_OBJECTS[Player] then
						local Drawings = CreateDrawings()
						ESP_OBJECTS[Player] = {
							player = Player,
							drawings = Drawings
						}
						UpdateESP(ESP_OBJECTS[Player], LocalRootPart)
					end
				end
			end
		else
			disableFunctions["PlayerEspToggle"]()
		end
	end,
}):AddKeyPicker("PlayerEspToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "Player ESP"
})


OtherBox:AddButton({
	Text = 'Boat esp',
	Default = false,
	Tooltip = '',
	Func = function()
		local iterate = {
			workspace.Boats,
			game.ReplicatedStorage.RS.UnloadNPCShips
		}
		for _, parent in ipairs(iterate) do
			for _, boat in ipairs(parent:GetChildren()) do
				if boat:IsA("Model") and boat.PrimaryPart then

					local dura = boat:FindFirstChild("Dura") 
					if not dura or dura.Value <= 0 then
						continue
					end

					if boat:FindFirstChild("Type") and boat.Type.Value then
						createText(`{boat.Type.Value} {boat.Name}`
							, Color3.new(0,1,0), boat.PrimaryPart)
						continue
					end
					createText(boat.Name
						, Color3.new(0,1,0), boat.PrimaryPart)
				end
			end
		end
	end
})

Options.ChestEspColor:OnChanged(function()
	for _, esp in chestEsps do
		esp.EspText.TextColor3 = Options.ChestEspColor.Value
	end
end)

OtherBox:AddToggle("DarkSeaEsp", {
	Text = 'Dark sea  esp',
	Default = false,
	Tooltip = 'Allows you to see all prompts on loaded dark sea islands \n should include hecate, athenas pages, items etc',
	Callback = function(Value)
		if Value then
			for _, prompt in ipairs(workspace.Map.SeaContent.DarkSea:GetDescendants()) do
				if prompt:IsA("ProximityPrompt") or prompt.Name == "HecateEssence" or prompt.Name == "AthenaWisdom" then
					local parent = prompt.Parent
					local color = Color3.new(1,1,1)
					local text
					if  prompt.Name == "HecateEssence" then
						color = Color3.new(0.364706, 0, 1)
						text = "Hecate"
					elseif prompt.Name == "AthenaWisdom" then
						color = Color3.new(0.619608, 1, 0.482353)
						text = "Athena Note"
					else
						if prompt.ObjectText == "Prometheus's Acrimony" then
							color = Color3.new(1, 0.92549, 0.490196)
						end
						text = prompt.ObjectText
					end
					local parent = prompt.Parent
					if prompt.Name == "HecateEssence" or prompt.Name == "AthenaWisdom" then
						parent = prompt
					end
					local esp = createText(text, color, parent)
					DarkSeaEsps[prompt] = esp
				end
			end

			for _, chest in ipairs(workspace.Map.Temporary:GetChildren()) do
				local prox = chest:FindFirstChild("Prompt")
				if chest.Name == "Dark Sealed Chest" and prox then
					local esp = createText("Dark Sealed Chest", Color3.new(0.564706, 0.419608, 0.654902), chest)
					DarkSeaEsps[chest] = esp
				end
			end

			DarkSeaConns[1] = workspace.Map.SeaContent.DarkSea.DescendantAdded:Connect(function(child)
				if child:IsA("ProximityPrompt") or child.Name == "HecateEssence" or child.Name == "AthenaWisdom" then
					local color = Color3.new(1,1,1)
					local text
					if child.Name == "HecateEssence" then
						color = Color3.new(0.364706, 0, 1)
						text = "Hecate"
					elseif child.Name == "AthenaWisdom" then
						color = Color3.new(0.619608, 1, 0.482353)
						text = "Athena Note"
					else
						if child.ObjectText == "Prometheus's Acrimony" then
							color = Color3.new(1, 0.92549, 0.490196)
						end
						text = child.ObjectText
					end
					local parent = child.Parent
					if child.Name == "HecateEssence" or child.Name == "AthenaWisdom" then
						parent = child
					end
					local esp = createText(text, color, parent)
					DarkSeaEsps[child] = esp
				end
			end)

			DarkSeaConns[2] = workspace.Map.Temporary.ChildAdded:Connect(function(chest)
				local prox = chest:FindFirstChild("Prompt")
				if chest.Name == "Dark Sealed Chest" and prox then
					local esp = createText("Dark Sealed Chest", Color3.new(0.564706, 0.419608, 0.654902), chest)
					DarkSeaEsps[chest] = esp
				end
			end)

			DarkSeaConns[3] = workspace.Map.SeaContent.DarkSea.DescendantRemoving:Connect(function(child)
				if child:IsA("ProximityPrompt") then
					DarkSeaEsps[child]:Destroy()
					DarkSeaEsps[child] = nil
				end
			end)

			DarkSeaConns[4] =  workspace.Map.Temporary.ChildRemoved:Connect(function(child)
				if child.Name == "Dark Sealed Chest" then
					DarkSeaEsps[child]:Destroy()
					DarkSeaEsps[child] = nil
				end
			end)
		else
			disableFunctions["DarkSeaEsp"]()
		end
	end,
}):AddKeyPicker("ChestEspToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "Darksea esp"
})

OtherBox:AddButton({
	Text = 'Infinite Stamina',
	Tooltip = "Gives you a very big amount of stamina. Has no downside. \n Cba making a reset. There's no reason to turn it off anyway",
	Func = function()
		ReplicatedStorage.RS.Remotes.Combat.StaminaCost:FireServer(-3400)
		player.CharacterAdded:Connect(function()
			local hum = player:WaitForChild("Humanoid", 10)
			if hum then
				ReplicatedStorage.RS.Remotes.Combat.StaminaCost:FireServer(-3400)
			end
		end)
	end,
})

OtherBox:AddButton({
	Text = 'Disable ship collision damage',
	Tooltip = 'Your ship no longer takes damage when bumping into stuff \n Effect goes away on ship despawn/refresh',
	Func = function(Value)
		local boat = workspace.Boats:FindFirstChild(name)
		if boat then
			for _, transmitter in ipairs(boat:GetDescendants()) do
				if transmitter:IsA("TouchTransmitter") then
					transmitter:Destroy()
				end
			end
		end
	end,
})

OtherBox:AddButton({
	Text = "Optimize lighting",
	Tooltip = "Disable fog, shadows, make it brighter, etc",
	Func = function(Value)
		for _, sky in workspace.Camera:GetChildren() do
			if sky.Name == "DarkSky1" or sky.Name == "DarkSky2" then
				sky:Destroy()
			end
		end

		local lighting = game:GetService("Lighting")
		local folder = Instance.new("Folder")
		local atmo = lighting:FindFirstChild("Atmosphere")
		folder.Parent = lighting
		folder.Name = "Atmosphere"
		if atmo then atmo:Destroy() end

		lighting.GlobalShadows = false
		lighting.Ambient = Color3.new(1,1,1)
		lighting.OutdoorAmbient = Color3.new(1,1,1)

		workspace.Camera.ChildAdded:Connect(function(sky)
			if sky.Name == "DarkSky1" or sky.Name == "DarkSky2" then
				sky:Destroy()
			end
		end)

		for _, effect in lighting:GetChildren() do
			if effect:IsA("ColorCorrectionEffect") or effect:IsA("SunRaysEffect") or effect:IsA("BlurEffect") or effect:IsA("BloomEffect") then
				effect.Enabled = false
			end
		end
	end,
})

OtherBox:AddButton({
	Text = "Disable fall damage",
	Tooltip = "Disables fall damage",
	Func = function()
		if game.ReplicatedStorage.RS.Remotes.Combat:FindFirstChild("FallDamage") then
			game.ReplicatedStorage.RS.Remotes.Combat.FallDamage:Destroy()
		end
	end,
})

OtherBox:AddButton({
	Text = "Wash",
	Tooltip = "Removes dark sea weater poison",
	Func = function()
		if game.ReplicatedStorage.RS.Remotes.Boats:FindFirstChild("Wash") then
			game.ReplicatedStorage.RS.Remotes.Boats.Wash:FireServer()
		end
	end,
})

OtherBox:AddButton({
	Text = "Infinite Zoom",
	Tooltip = "Allows you to scroll your camera forever",
	Func = function()
		game.Players.LocalPlayer.CameraMaxZoomDistance = 1e9
	end,
})

OtherBox:AddInput("RodBox",
	{
		Default = "Wooden Rod",	
		Numeric = false,
		Finished = true,
		Text = "Write fishing rod",
		Tooltip = ""
	}
)


OtherBox:AddInput("BaitBox",
	{
		Default = "Normal Bait",	
		Numeric = false,
		Finished = true,
		Text = "Write bait name",
		Tooltip = ""
	}
)

OtherBox:AddToggle("AutoFishToggle", {
	Text = "Silent Autofish",
	Tooltip = "Catches fish without using rod",
	Default = false,
	Callback = function(Value)
		if Value then
			autoFishConn = game.ReplicatedStorage.RS.Remotes.Misc.FishEvent.OnClientEvent:Connect(function(arg1, arg2, ...)
				if arg1 == player and arg2 == "Bite" then
					for i = 1, 10 do
						game:GetService("ReplicatedStorage").RS.Remotes.Misc.FishState:FireServer("Reel")
						task.wait()
					end

					args = {
						[1] = player.Backpack:FindFirstChild(Options.RodBox.Value),
						[3] = Vector3.new(0/0 --[[NaN]], 0/0 --[[NaN]], 0/0 --[[NaN]]),
						[4] = Options.BaitBox.Value
					}

					ReplicatedStorage.RS.Remotes.Misc.FishClock:FireServer(unpack(args))

				end
			end)

			local args = {
				[1] = player.Backpack:FindFirstChild(Options.RodBox.Value),
				[3] = Vector3.new(0/0 --[[NaN]], 0/0 --[[NaN]], 0/0 --[[NaN]]),
				[4] = Options.BaitBox.Value
			}
			ReplicatedStorage.RS.Remotes.Misc.FishClock:FireServer(unpack(args))

		else 
			disableFunctions["AutoFishToggle"]()
			game:GetService("ReplicatedStorage").RS.Remotes.Misc.FishState:FireServer("StopClock")

		end
	end,
})

OtherBox:AddButton({
	Text = "Delete all Esps",
	Tooltip = "Deletes all current esps",
	Func = function()
		for _, esp in espParts:GetChildren() do
			esp:Destroy()
		end
	end,
})

LeftOpBox:AddToggle('PvpToggleKill', {
	Text = 'Target Player',
	Default = false,
	Tooltip = 'Will kill nearest player'
})

LeftOpBox:AddToggle("PveToggleKill",{
	Text = 'Target Npc',
	Default = true,
	Tooltip = 'Will kill nearest NPC'
})

LeftOpBox:AddButton({
	Text = "Kill nearest enemy (LOW RISK)",
	Default = false,
	Tooltip = "It will kill nearest enemy. \n Don't spam it on sea monsters. (will get you banned on death)",
	Func = function(Value)
		local function getClosestEnemy()
			if not character then return nil end

			local hrp = character:FindFirstChild("HumanoidRootPart")
			if not hrp then return nil end
			local pve = Toggles.PveToggleKill.Value
			local pvp = Toggles.PvpToggleKill.Value

			local mobDist = math.huge
			local closestEnemy
			for enemy in pairs(enemies) do
				if enemy:IsA("Model") then
					if not pvp and enemy.Parent == workspace then
						continue
					end
					if not pve and enemy.Parent == workspace.Enemies then
						continue
					end

					local enemyHRP = enemy:FindFirstChild("HumanoidRootPart")
					local hum = enemy:FindFirstChildOfClass("Humanoid")
					if hum then
						if hum.Health <= 0 then
							continue
						end
					else
						local atts = enemy:FindFirstChild("Attributes")
						if atts then
							local Health = atts:FindFirstChild("Health")
							if not Health or Health.Value <= 0 then
								continue
							end
						end
					end
					if enemyHRP then
						local distance = (enemyHRP.Position - hrp.Position).Magnitude
						if distance < mobDist then
							mobDist = distance
							closestEnemy = enemy
						end
					end
				end
			end
			return closestEnemy
		end
		local closestEnemy = getClosestEnemy()
		local args = {
			game:GetService("Players").LocalPlayer.Character,
			closestEnemy,
			"Metal Magic",
			"3",
			'["Pulsar",9999999999999999999999999999,20,20,true,"Two Hands","25","Pulsar","Drill","Metal"]',
			1,
			1
		}
		game.ReplicatedStorage.RS.Remotes.Magic.DealAttackDamage:FireServer(unpack(args))
	end
})

LeftOpBox:AddSlider('KillAuraSlider', {
	Text = 'Kill aura distance',
	Default = 100,
	Min = 0,
	Max = 500,
	Rounding = 1,
	Compact = false,
})


LeftOpBox:AddToggle("KillAuraToggle", {
	Text = 'Kill Aura',
	Default = false,
	Tooltip = 'Gives you a kill aura. \nDont fly large distances on the sea with this on',
	Callback = function(Value)
		if Value then
			killAuraTask = task.spawn(function()
				while Toggles.KillAuraToggle.Value do
					local closestEnemy
					local pvp = Toggles.PvpToggleKill.Value
					local pve = Toggles.PveToggleKill.Value
					for enemy in pairs(enemies) do
						if not pvp and enemy.Parent == workspace then
							continue
						end
						if not pve and enemy.Parent == workspace.Enemies then
							continue
						end
						local enemyHRP = enemy:FindFirstChild("HumanoidRootPart")
						local hum = enemy:FindFirstChildOfClass("Humanoid")
						if hum then
							if hum.Health <= 0 then
								continue
							end
						else
							local atts = enemy:FindFirstChild("Attributes")
							if atts then
								local Health = atts:FindFirstChild("Health")
								if not Health or Health.Value <= 0 then
									continue
								end
							end
						end
						local plrHRP = character and character:FindFirstChild("HumanoidRootPart")
						if enemyHRP and plrHRP then
							local pos = enemyHRP.Position
							local plrPos = plrHRP.Position
							local distance = (pos - plrPos).Magnitude
							if distance <= Options.KillAuraSlider.Value then
								local args = {
									game:GetService("Players").LocalPlayer.Character,
									enemy,
									"Metal Magic",
									"3",
									'["Pulsar", 9999999999999999999999999999,20,20,true,"Two Hands","25","Pulsar","Drill","Metal"]',
									1,
									1
								}
								game.ReplicatedStorage.RS.Remotes.Magic.DealAttackDamage:FireServer(unpack(args))
							end
						end
					end
					task.wait(0.5)
				end
			end)
		else
			killAuraTask = nil
		end
	end,
}):AddKeyPicker("KillAuraToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "Kill Aura"
})


LeftOpBox:AddSlider('DamageMultiSlider', {
	Text = 'Damage Multiplier',
	Default = 1,
	Min = 1,
	Max = 100,
	Rounding = 1,
	Compact = false,
})

LeftOpBox:AddToggle("GodModeToggle", {
	Text = 'Npc God Mode \ Dmg Multi',
	Default = false,
	Tooltip = 'Makes npcs unable to hit you / deal increased dmg \nrequires hookmetamethod',
	Callback = function(Value)
		if Value then
			godModeTask = hookmetamethod(game, "__namecall", newcclosure(function(remote, ...)
				local getmethod = getnamecallmethod or getnamecall
				if getmethod and not checkcaller() then
					local method = getmethod()
					if method == "FireServer" then
						local args = {...}
						local function damageMulti()
							for i = 1, math.floor(Options.DamageMultiSlider.Value) do
								godModeTask(remote, unpack(args))
								task.wait()
							end
						end
						if remote.Name == "TouchDamage" then
							return
						elseif remote.Name == "DealBossDamage" then
							if args[2] == character then
								return
							end
						elseif remote.Name == "TakeSideDamage" then
							return
						elseif remote.Name == "DealAttackDamage" then
							if args[2] == character then
								return
							else
								damageMulti()
								return
							end
						elseif remote.Name == "DealWeaponDamage" then
							if args[3] == character then
								return
							else
								damageMulti()
								return
							end
						elseif remote.Name == "DealSWDamage" then
							if args[3] == character then
								return
							else
								damageMulti()
								return
							end
						elseif remote.Name == "DealStrengthDamage" then
							if args[3] == character then
								return
							else
								damageMulti()
								return
							end
						elseif remote.Name == "DealAnimalDamage" then
							if args[2] == character then
								return
							end
						end
					end
				end
				return godModeTask(remote, ...)
			end))
		else
			disableFunctions["GodModeToggle"]()
		end
	end,
}):AddKeyPicker("GodModeToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "God Mode / Dmg Multi"
})


RightOpBox:AddInput("ItemName",
	{
		Default = "",
		Finished = false,
		Text = "Item to modify",
		Tooltip = "Modifies the stats of the item. \nMake sure to put the item name (enchant name not included)"
	}
)

RightOpBox:AddInput("SizeStat",
	{
		Default = "",
		Numeric = true,
		Finished = false,
		Text = "Size stat",
		Tooltip = ""
	}
)

RightOpBox:AddInput("RangeStat",
	{
		Default = "",
		Numeric = true,
		Finished = false,
		Text = "Range stat",
		Tooltip = ""
	}
)

RightOpBox:AddInput("DexterityStat",
	{
		Default = "",
		Numeric = true,
		Finished = false,
		Text = "Dexterity stat",
		Tooltip = ""
	}
)

RightOpBox:AddToggle("ItemStatToggle", {
	Text = "Apply stats",
	Tooltip = "Applies the select stats to selected item. \n (toggle bugged)",
	Default = false,
	Callback = function(Value)
			if Value then
			local modu = require(game.ReplicatedStorage.RS.Modules.Inventory)
			local item = modu.Items[Options.ItemName.Value]
			local istats = item["Stats"]
			local size = tonumber(Options.SizeStat.Value)
			local range = tonumber(Options.RangeStat.Value)
			local dexterity = tonumber(Options.DexterityStat.Value)
			local values = {
				Size = size,
				Range = range,
				Dexterity = dexterity
			} 
			if istats then
				
				for i, v in pairs(values) do
					if v then
						istats[i] = v
					end
				end
			else
				item["Stats"] = values
			end
			end
	end,
})


LeftOpBox:AddToggle('PvpBoatToggle', {
	Text = 'Target Player THESE FUNCTIOS NEED A FIGHTING STYLE',
	Default = false,
	Tooltip = 'Will kill nearest player boat'
})

LeftOpBox:AddToggle("PveBoatToggle",{
	Text = 'Target Npc',
	Default = true,
	Tooltip = 'Will kill nearest NPC boat'
})

LeftOpBox:AddInput("FightingStyleBox", {
	Text = "Equipped fighting style",
	Default = "Basic Combat",
	Tooltip = "You need to write a fighting style you have equipped for it to work"
	
})

LeftOpBox:AddButton({
	Text = "Destroy nearest boat",
	Default = false,
	Tooltip = "Destroys the nearest boat",
	Func = function(Value)
		local function getClosestBoat()
			if not character then return nil end

			local hrp = character:FindFirstChild("HumanoidRootPart")
			if not hrp then return nil end
			local pve = Toggles.PvpBoatToggle.Value
			local pvp = Toggles.PveBoatToggle.Value

			local bestDist = math.huge
			local closestBoat
			for _, boat in ipairs(workspace.Boats:GetChildren()) do
				if boat:IsA("Model") then
					if not pvp and boat:FindFirstChild("Owner") and boat.Owner.Value and boat.Owner.Value ~= player then
						continue
					end
					if not pve and not boat:FindFirstChild("Owner") then
						continue
					end

					local primaryPart = boat.PrimaryPart
					if not primaryPart then
						continue
					end
					
					local dura = boat:FindFirstChild("Dura") 
					if not dura or dura.Value <= 0 then
						continue
					end

						local distance = (primaryPart.Position - hrp.Position).Magnitude
						if distance < bestDist then
							bestDist = distance
							closestBoat = boat
					end
				end
			end
			return closestBoat
		end
		local boat = getClosestBoat()
		for i = 1, 500 do
			local args = {
				0,
				character,
				boat,
				player.Backpack:FindFirstChild(Options.FightingStyleBox.Value),
				"Attack"
			}
			game.ReplicatedStorage.RS.Remotes.Combat.DealDamageBoat3:FireServer(unpack(args))
 			task.wait()
		end
	end
})

LeftOpBox:AddSlider('BoatKillAuraSlider', {
	Text = 'Kill boat aura distance',
	Default = 1000,
	Min = 0,
	Max = 2500,
	Rounding = 1,
	Compact = false,
})


local boatKillAuraTask
LeftOpBox:AddToggle("BoatKillAura", {
	Text = 'Boat Kill Aura',
	Default = false,
	Tooltip = 'Gives you a boat kill aura',
	Callback = function(Value)
		if Value then
			boatKillAuraTask = task.spawn(function()
				while Toggles.BoatKillAura.Value do
					local closestEnemy
					local pvp = Toggles.PvpBoatToggle.Value
					local pve = Toggles.PveBoatToggle.Value
					for _, boat in ipairs(workspace.Boats:GetChildren()) do
						if not pvp and boat:FindFirstChild("Owner") and boat.Owner.Value and boat.Owner.Value ~= player then
							continue
						end
						if not pve and not boat:FindFirstChild("Owner") then
							continue
						end

						local primaryPart = boat.PrimaryPart
						if not primaryPart then
							continue
						end

						local dura = boat:FindFirstChild("Dura") 
						if not dura or dura.Value <= 0 then
							continue
						end

						local plrHRP = character and character:FindFirstChild("HumanoidRootPart")
						if plrHRP then
							local pos = primaryPart.Position
							local plrPos = plrHRP.Position
							local distance = (pos - plrPos).Magnitude
							if distance <= Options.BoatKillAuraSlider.Value then
								for i = 1, 100 do
									local args = {
										0,
										character,
										boat,
										player.Backpack:FindFirstChild(Options.FightingStyleBox.Value),
										"Attack"
									}
									game.ReplicatedStorage.RS.Remotes.Combat.DealDamageBoat3:FireServer(unpack(args))
									task.wait()
								end
							end
						end
					end
					task.wait(0.35)
				end
			end)
		else
			boatKillAuraTask = nil
		end
	end,
}):AddKeyPicker("BoatKillAuraToggleKey", {
	Default = "",
	SyncToggleState = true,
	Text = "Boat Kill Aura"
})


Library:OnUnload(function()
	for _, func in pairs(disableFunctions) do
		func()
	end
	espParts:Destroy()
	killAuraTask = nil
	boatKillAuraTask = nil
	print('Unloaded!')
	Library.Unloaded = true
end)
----------

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddToggle('Keybindmenu', {
	Text = "Toggle keybind menu",
	Default = true,
	Callback = function(Value)
		Library.KeybindFrame.Visible = Value
	end

}):AddKeyPicker('Keybindmenupick', {
	Default = '',
	SyncToggleState = true,
	Text = 'toggleKeybind',
	NoUI = true, 
})

MenuGroup:AddButton('Copy discord link', function() setclipboard("https://discord.gg/vHR8gXc4Ag") end)

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

ThemeManager:SetFolder('KintamaHack')
SaveManager:SetFolder("KintamaHack")

SaveManager:BuildConfigSection(Tabs['UI Settings'])

ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()

if Toggles.AutoFishToggle.Value then
	autoFishConn = game.ReplicatedStorage.RS.Remotes.Misc.FishEvent.OnClientEvent:Connect(function(arg1, arg2, ...)
		if arg1 == player and arg2 == "Bite" then
			for i = 1, 10 do
				game:GetService("ReplicatedStorage").RS.Remotes.Misc.FishState:FireServer("Reel")
				task.wait()
			end

			args = {
				[1] = player.Backpack:FindFirstChild(Options.RodBox.Value),
				[3] = Vector3.new(0/0 --[[NaN]], 0/0 --[[NaN]], 0/0 --[[NaN]]),
				[4] = Options.BaitBox.Value
			}

			ReplicatedStorage.RS.Remotes.Misc.FishClock:FireServer(unpack(args))

		end
	end)

	local args = {
		[1] = player.Backpack:FindFirstChild(Options.RodBox.Value),
		[3] = Vector3.new(0/0 --[[NaN]], 0/0 --[[NaN]], 0/0 --[[NaN]]),
		[4] = Options.BaitBox.Value
	}
	ReplicatedStorage.RS.Remotes.Misc.FishClock:FireServer(unpack(args))
end
